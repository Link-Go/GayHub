## Linux系统之进程状态

- R (TASK_RUNNING)，可执行状态
    - 只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进而，进程调度器就从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。
    -  很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。



- S (TASK_INTERRUPTIBLE)，可中断的睡眠状态
    - 处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构（进程控制块）被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。
    - 通过ps命令会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么几个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。



- D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态
    - 与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。
    - 绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态
    -  而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。
    -  例如，在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。



- T/t (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态
    - T (TASK_STOPPED)状态：向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。
    - t (TASK_STOPPED)状态：当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb（UNIX及UNIX-like下的调试工具）调试中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。
    -  对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是表示进程暂停下来。而TASK_TRACED状态相当于在TASK_STOPPED之上多了一层保护，处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过ptrace系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。



- Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程
    - 进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。
    - 之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息（保存在task_struct里）。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。
    - 僵尸进程 vs 孤儿进程
        - 僵尸进程
            - 一个进程使用 fork 创建子进程，如果子进程退出后父进程没有调用 wait 或 waitpid 获取子进程的状态信息，并将子进程释放掉。那么子进程的进程描述符仍然保存在系统中，仍然占用进程表，此时进程就处于僵尸状态。
            - 子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。出现僵尸状态可能有两种情况：
                -  第一种情况，父进程收到通知还没来得及完成收尸，此时正常；
                - 第二种情况，父进程收尸出现异常，此时，只要父进程不退出，子进程的僵尸状态就一直存在，可以通过杀死父进程或者重启来解决。
        - 孤儿进程
            - 父进程退出，相应的一个或多个子进程还在运行，那么那些子进程将处于孤儿状态，成为孤儿进程。这些进程会被托管给别的进程，托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。1号进程，pid为1的进程，又称init进程。
    - init 进程
        - 执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）
        - 在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。

- X (TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁
    - 进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程。或者父进程通过设置SIGCHLD信号的handler为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。）
    - 此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。
